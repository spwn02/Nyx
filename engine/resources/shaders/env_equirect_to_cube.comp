#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D u_Equirect;
layout(rgba16f, binding = 1) uniform writeonly imageCube u_OutCube;

const float PI = 3.14159265359;

// Cubemap face directions (OpenGL convention)
vec3 faceDir(uint face, vec2 uv) {
  if (face == 0u)
    return normalize(vec3(1.0, uv.y, -uv.x)); // +X
  if (face == 1u)
    return normalize(vec3(-1.0, uv.y, uv.x)); // -X
  if (face == 2u)
    return normalize(vec3(uv.x, 1.0, -uv.y)); // +Y
  if (face == 3u)
    return normalize(vec3(uv.x, -1.0, uv.y)); // -Y
  if (face == 4u)
    return normalize(vec3(uv.x, uv.y, 1.0)); // +Z
  return normalize(vec3(-uv.x, uv.y, -1.0)); // -Z
}

vec2 dirToEquirectUV(vec3 d) {
  // equirect: u = atan2(z,x), v = asin(y)
  float phi = atan(d.z, d.x);
  float theta = asin(clamp(d.y, -1.0, 1.0));
  float u = (phi / (2.0 * PI)) + 0.5;
  float v = (theta / PI) + 0.5;
  return vec2(u, v);
}

void main() {
  uvec3 gid = gl_GlobalInvocationID;
  uint face = gid.z; // 0..5

  ivec2 size = imageSize(u_OutCube).xy;
  if (int(gid.x) >= size.x || int(gid.y) >= size.y)
    return;

  vec2 uv = (vec2(gid.xy) + 0.5) / vec2(size);
  uv = uv * 2.0 - 1.0;

  vec3 dir = faceDir(face, uv);
  vec2 euv = dirToEquirectUV(dir);

  vec3 hdr = texture(u_Equirect, euv).rgb;
  
  // Swap faces 2 and 3 (top/bottom) to correct for coordinate system
  uint outFace = face;
  if (face == 2u) outFace = 3u;
  else if (face == 3u) outFace = 2u;
  
  imageStore(u_OutCube, ivec3(gid.xy, int(outFace)), vec4(hdr, 1.0));
}
