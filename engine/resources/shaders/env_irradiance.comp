#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform samplerCube u_EnvCube;
layout(rgba16f, binding = 1) uniform writeonly imageCube u_Irr;

const float PI = 3.14159265359;

vec3 faceDir(uint face, vec2 uv) {
  if (face == 0u)
    return normalize(vec3(1.0, uv.y, -uv.x));
  if (face == 1u)
    return normalize(vec3(-1.0, uv.y, uv.x));
  if (face == 2u)
    return normalize(vec3(uv.x, 1.0, -uv.y));
  if (face == 3u)
    return normalize(vec3(uv.x, -1.0, uv.y));
  if (face == 4u)
    return normalize(vec3(uv.x, uv.y, 1.0));
  return normalize(vec3(-uv.x, uv.y, -1.0));
}

// Cosine-weighted hemisphere sampling around N.
// Cheap-ish version: fixed stratified sampling.
vec3 irradiance(vec3 N) {
  vec3 up = abs(N.y) < 0.999 ? vec3(0, 1, 0) : vec3(1, 0, 0);
  vec3 T = normalize(cross(up, N));
  vec3 B = cross(N, T);

  const int S = 64; // keep small; this runs offline-on-change
  vec3 sum = vec3(0.0);
  float wsum = 0.0;

  for (int i = 0; i < S; ++i) {
    float a = float(i) / float(S);
    float phi = 2.0 * PI * a;

    // cosine-ish elevation distribution
    float r = fract(sin(float(i) * 43758.5453) * 143758.5453);
    float cosTheta = sqrt(1.0 - r);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    vec3 H = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    vec3 L = normalize(T * H.x + B * H.y + N * H.z);

    float ndl = max(dot(N, L), 0.0);
    vec3 c = texture(u_EnvCube, L).rgb;
    sum += c * ndl;
    wsum += ndl;
  }

  return (wsum > 0.0) ? (sum / wsum) : vec3(0.0);
}

void main() {
  uvec3 gid = gl_GlobalInvocationID;
  uint face = gid.z;

  ivec2 size = imageSize(u_Irr).xy;
  if (int(gid.x) >= size.x || int(gid.y) >= size.y)
    return;

  vec2 uv = (vec2(gid.xy) + 0.5) / vec2(size);
  uv = uv * 2.0 - 1.0;

  vec3 N = faceDir(face, uv);
  vec3 irr = irradiance(N);

  imageStore(u_Irr, ivec3(gid.xy, int(face)), vec4(irr, 1.0));
}
