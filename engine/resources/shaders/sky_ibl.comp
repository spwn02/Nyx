#version 460 core

layout(local_size_x = 16, local_size_y = 16) in;

#include "include/SkyCommon.glsl"

layout(binding = 0) uniform samplerCube u_EnvCube;
layout(rgba16f, binding = 1) uniform writeonly image2D u_HDR;
layout(binding = 3) uniform sampler2D u_Depth;

// Rotate direction around +Y by yaw radians
vec3 rotateY(vec3 v, float yaw) {
  float c = cos(yaw), s = sin(yaw);
  return vec3(c*v.x + s*v.z, v.y, -s*v.x + c*v.z);
}

// Reconstruct world ray from pixel using invViewProj
vec3 reconstructWorldDir(ivec2 pix, ivec2 size) {
  vec2 uv = (vec2(pix) + 0.5) / vec2(size);
  vec2 ndc = uv * 2.0 - 1.0;

  vec4 p0 = gSky.uInvViewProj * vec4(ndc, 0.0, 1.0);
  vec4 p1 = gSky.uInvViewProj * vec4(ndc, 1.0, 1.0);
  vec3 w0 = p0.xyz / p0.w;
  vec3 w1 = p1.xyz / p1.w;

  vec3 dir = normalize(w1 - w0);
  return dir;
}

void main() {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 sz = imageSize(u_HDR);
  if (pix.x >= sz.x || pix.y >= sz.y)
    return;

  float d = texelFetch(u_Depth, pix, 0).r;
  if (d < 0.999999)
    return;

  // If background disabled, skip
  if (gSky.uSkyParams.w < 0.5)
    return;

  vec3 dirW = reconstructWorldDir(pix, sz);
  dirW = rotateY(dirW, gSky.uSkyParams.z);

  // Sample env cubemap at base LOD (sky background)
  vec3 env = textureLod(u_EnvCube, dirW, 0.0).rgb;

  float intensity = gSky.uSkyParams.x;
  float exposure = exp2(gSky.uSkyParams.y);

  vec3 hdr = env * intensity * exposure;

  imageStore(u_HDR, pix, vec4(hdr, 1.0));
}
